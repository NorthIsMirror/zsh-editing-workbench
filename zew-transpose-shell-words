# Transpose shell-words, i.e. parts of lines obtained by (Z) flag, i.e.
# as if zsh parsed the line.
#
# Code to activate the functionality with binding to Alt-t:
# autoload zew-transpose-shell-words
# zle -N zew-transpose-shell-words
# bindkey "^[t" zew-transpose-shell-words

local curcontext=":zle:$WIDGET"
local MATCH MBEGIN MEND i

# Will remember white spaces before each shell word
typeset -a spaces
spaces=()

# Working variable for $BUFFER
local buf="$BUFFER"

# Split the buffer
typeset -a bufarr
bufarr=( "${(Z+n+)buf}" )

integer size="$#bufarr"
integer char_count=0
integer selected_shell_word=-1

# (Z) handles spaces nicely, but we need them for the user
for (( i=1; i<=size; i++ )); do
    local shell_word="$bufarr[i]"

    # In general, $buf can start with white spaces
    # We will not search for them, but instead for
    # leading character of current shell word,
    # negated. This is an ambition to completely
    # avoid character classes

    # First remove and remember spaces
    buf="${buf##(#m)[^$shell_word[1]]#}"
    spaces[i]="$MATCH"
    MATCH=""
    # Second, remove (Z)-generated shell word
    buf="${buf#(#m)$shell_word}"

    # If shell word not found, return from the
    # function doing nothing. This shoudln't happen
    [ -z "$MATCH" ] && return 0;

    #
    # Count how many characters we processed,
    # to know which shell word is active
    #

    # Spaces point to previous shell word
    # Visual cursor right after spaces (-ge) -> not enough to select previous word (-gt required)
    char_count=char_count+"$#spaces[i]"
    [[ "$selected_shell_word" -eq -1 && "$char_count" -gt "$CURSOR" ]] && selected_shell_word=i-1

    # Actual characters point to current shell word
    # Visual cursor right after letters (-ge) -> enough to select current word
    char_count=char_count+"$#shell_word"
    [[ "$selected_shell_word" -eq -1 && "$char_count" -ge "$CURSOR" ]] && selected_shell_word=i
done

# What's left in $buf can be only white spaces
spaces[i]="$buf"
char_count=char_count+"$#spaces[i]"

# Detect which shell word is active
# This one is for trailing white spaces
# Visual cursor right after spaces (-ge) -> enough to select last word
[[ "$selected_shell_word" -eq -1 && "$char_count" -ge "$CURSOR" ]] && selected_shell_word=i-1

# No active shell word found (shouldn't happen) (-1)
# or it's the first shell word (1), or word before first
# shell word (0)? Return
[ "$selected_shell_word" -le 1 ] && return 0

# Swap shell words
local tmp="$bufarr[selected_shell_word]"
bufarr[selected_shell_word]="$bufarr[selected_shell_word-1]"
bufarr[selected_shell_word-1]="$tmp"

# Build BUFFER
integer newcursor
BUFFER=""
for (( i=1; i<=size; i++ )); do
    BUFFER+="$spaces[i]$bufarr[i]"
    [ "$i" = "$selected_shell_word" ] && newcursor="$#BUFFER"
done
CURSOR="$newcursor"

# Append final white spaces
BUFFER+="$spaces[i]"

return 0
