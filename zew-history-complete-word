emulate -LR zsh
setopt typesetsilent extendedglob noshortloops

# When an error, then no cursor keys bindings
zmodload zsh/terminfo 2>/dev/null
zmodload zsh/termcap 2>/dev/null

# Prepare output variables for zew-process-buffer
local ZEW_PB_WORDS ZEW_PB_WORDS_BEGINNINGS ZEW_PB_SPACES 
local ZEW_PB_SELECTED_WORD ZEW_PB_LEFT ZEW_PB_RIGHT

autoload zew-process-buffer
zew-process-buffer "$BUFFER"

typeset -g __zew_hcw_index __zew_hcw_left __zew_hcw_right __zew_hcw_finished
typeset -gaU __zew_hcw_found

# Consecutive call?
# zle recursive-edit will not change LASTWIDGET,
# so the second call must be detected via first_call
if [[ ("$first_call" = "1" || "${WIDGET%-backwards}" = "${LASTWIDGET%-backwards}") && "$__zew_hcw_finished" != "1" ]]; then
    integer first_call=0
    [[ "$WIDGET" != *-backwards ]] && (( __zew_hcw_index ++ )) || (( __zew_hcw_index -- ))
else
    integer first_call=1
    # '0' will get changed into $to_display limit
    [[ "$WIDGET" != *-backwards ]] && __zew_hcw_index="1" || __zew_hcw_index="0"
    __zew_hcw_left="$ZEW_PB_LEFT"
    __zew_hcw_right="$ZEW_PB_RIGHT"
    __zew_hcw_found=( )
    __zew_hcw_finished="0"
fi

# Find history words matching $left ... $right
if [ "$#__zew_hcw_found" -eq "0" ]; then
    repeat 1; do
        __zew_hcw_found=( "${(@M)historywords:#(#i)$__zew_hcw_left*$__zew_hcw_right}" )
    done
fi

if [ "$#__zew_hcw_found" -le "0" ]; then
    zle -M "No matches found"
    return 0
fi

# Pagination, index value guards
integer page_size=$(( LINES / 2 ))
integer max_index="$#__zew_hcw_found"
[ "$page_size" -gt "$max_index" ] && page_size="$max_index"
[ "$__zew_hcw_index" -le 0 ] && __zew_hcw_index="$max_index"
[ "$__zew_hcw_index" -gt "$max_index" ] && __zew_hcw_index=1
integer page_start_idx=$(( ((__zew_hcw_index-1)/page_size)*page_size+1 ))
integer on_page_idx=$(( (__zew_hcw_index-1) % page_size + 1 ))

# Display matches
typeset -a disp_list
disp_list=( "${(@)__zew_hcw_found[page_start_idx,page_start_idx+page_size-1]}" )
disp_list[on_page_idx]="> ${disp_list[on_page_idx]} <"
zle -M -- \
"Searching for '${__zew_hcw_left}_${__zew_hcw_right}'. "\
"Element #$__zew_hcw_index of $max_index"$'\n'"${(F)disp_list}"

# Regenerate command line
buf=""
integer nwords="${#ZEW_PB_WORDS}"
integer newcursor=0
for (( i=1; i<=nwords; i++ )); do
    if [ "$i" = "$ZEW_PB_SELECTED_WORD" ]; then
        buf+="${ZEW_PB_SPACES[i]}${__zew_hcw_found[__zew_hcw_index]}"
        newcursor="$#buf"
    else
        buf+="${ZEW_PB_SPACES[i]}${ZEW_PB_WORDS[i]}"
    fi
done

# Set command line
BUFFER="$buf"
# Move cursor to the end of word
CURSOR="$newcursor"

if (( first_call ));then
    # Make the zhcw keymap a copy of the current main
    bindkey -N zhcw main

    local down_widget="${WIDGET%-backwards}"
    local up_widget="${down_widget}-backwards"

    # Manual, termcap, terminfo
    bindkey -M zhcw '^[OA' "$up_widget"
    bindkey -M zhcw '^[OB' "$down_widget"
    bindkey -M zhcw '^[[A' "$up_widget"
    bindkey -M zhcw '^[[B' "$down_widget"
    [ -n "$termcap[ku]" ] && bindkey -M zhcw "$termcap[ku]" "$up_widget"
    [ -n "$termcap[kd]" ] && bindkey -M zhcw "$termcap[kd]" "$down_widget"
    [ -n "$terminfo[kcuu1]" ] && bindkey -M zhcw "$terminfo[kcuu1]" "$up_widget"
    [ -n "$terminfo[kcud1]" ] && bindkey -M zhcw "$terminfo[kcud1]" "$down_widget"

    zle recursive-edit -K zhcw
    zle -M ""
    __zew_hcw_finished="1"
fi

# vim:ft=zsh
