setopt localoptions
setopt typesetsilent extendedglob noshortloops

typeset -a words spaces
words=( "${(Z+n+)BUFFER}" )
integer nwords="${#words}"
local buf="$BUFFER"

# Remove words one by one, counting characters,
# computing beginning of each word, to find
# place to break the word into 2 halves (for
# complete_in_word option)

local i word
integer char_count=0
typeset -a word_beginnings
integer selected_shell_word=-1

for (( i=1; i<=nwords; i++ )); do
    word="${words[i]}"

    # Remove white spaces
    buf="${buf##(#m)[^$word[1]]#}"
    # Count them
    char_count=char_count+"$#MATCH"
    # This is the beginning of current word
    word_beginnings[i]="$char_count"
    # Remember the spaces
    spaces[i]="$MATCH"

    # Remove the word
    MATCH=""
    buf="${buf#(#m)$word}"

    # If shell word not found, return. This shoudln't happen
    [ -z "$MATCH" ] && return 0

    # Spaces point to previous shell word
    # Visual cursor right after spaces (-ge) -> not enough to select previous word (-gt required)
    [[ "$selected_shell_word" -eq "-1" && "$char_count" -gt "$CURSOR" ]] && selected_shell_word=i-1

    # Actual characters point to current shell word
    # Visual cursor right after letters (-ge) -> enough to select current word
    char_count=char_count+"$#word"
    [[ "$selected_shell_word" -eq "-1" && "$char_count" -ge "$CURSOR" ]] && selected_shell_word=i
done 

# What's left in $buf can be only white spaces
# Visual cursor right after spaces (-ge) -> enough to select last word
char_count=char_count+"$#buf"
[[ "$selected_shell_word" -eq -1 && "$char_count" -ge "$CURSOR" ]] && selected_shell_word=i-1

# Divide words[selected_shell_word] into two halves
integer diff=$(( CURSOR - word_beginnings[selected_shell_word] ))
word="${words[selected_shell_word]}"
local left="${word[1,diff]}"
local right="${word[diff+1,-1]}"

# Find history words matching $left ... $right
typeset -a found
typeset -U found
repeat 1; do
    found=( "${(@M)historywords:#(#i)$~left*$~right}" )
done
#print -rl "Found:" "$found[@]"

# Regenerate command line
buf=""
for (( i=1; i<=nwords; i++ )); do
    if [ "$i" = "$selected_shell_word" ]; then
        buf+="${spaces[i]}${found[2]}"
    else
        buf+="${spaces[i]}${words[i]}"
    fi
done
BUFFER="$buf"

# vim:ft=zsh
